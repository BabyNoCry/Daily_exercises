猴子分桃

老猴子辛苦了一辈子，给那群小猴子们留下了一笔巨大的财富――一大堆桃子。老猴子决定把这些桃子分给小猴子。
第一个猴子来了，它把桃子分成五堆，五堆一样多，但还多出一个。它把剩下的一个留给老猴子，自己拿走其中的一堆。
第二个猴子来了，它把桃子分成五堆，五堆一样多，但又多出一个。它把多出的一个留给老猴子，自己拿走其中的一堆。
后来的小猴子都如此照办。最后剩下的桃子全部留给老猴子。
这里有n只小猴子，请你写个程序计算一下在开始时至少有多少个桃子，以及最后老猴子最少能得到几个桃子。

输入描述:
输入包括多组测试数据。
每组测试数据包括一个整数n(1≤n≤20)。
输入以0结束，该行不做处理。


输出描述:
每组测试数据对应一行输出。
包括两个整数a，b。
分别代表开始时最小需要的桃子数，和结束后老猴子最少能得到的桃子数。
示例1
输入
5
1
0
输出
3121 1025


分析：
纯数学题，思路与前面人的思路不太一样，不用借桃子，直接根据题意来进行求解，设最少需要桃子X个：
 
第一次经过题目的处理剩余桃子数目为：4/5(X-1)=(4/5)*X-(4/5)；
 
第二次剩余桃子个数为：4/5(4/5(X-1)-1)=((4/5)^2)*X-(4/5)^2-(4/5)；
 
第三次剩余桃子个数为：4/5(4/5(4/5(X-1)-1)-1)=((4/5)^3)*X-(4/5)^3-(4/5)^2-(4/5)；
 
......
 
依次类推，经过n只猴子的类似处理，剩余桃子数为：
 
4/5(4/5(4/5(....(4/5(X-1)...)-1)-1)-1)=((4/5)^n)*X)-(4/5)^n-(4/5)^(n-1)-...-(4/5)
 
=((4/5)^n)*X)-4[1-(4/5)^n]
 
=(X+4)*(4/5)^n-4
 
因此，同前人的推导一致，最终，只需要满足x+4的值为5^n次方则可以保证最后能得到一个整数，满足题目的要求，
代码：
#include<stdio.h>
#include<math.h>
     
int main()
{
    unsigned long n, a, b;
    while(scanf("%lu", &n)){
        if(n == 0) break;
         
        a = (unsigned long)pow(5, (double)n);
        b = (unsigned long)pow(4, (double)n);
         
        printf("%lu %lu\n", a-4, b-4+n);
    }
    return 0;
}


[编程题] 奇数位上都是奇数或者偶数位上都是偶数
给定一个长度不小于2的数组arr。 写一个函数调整arr，
使arr中要么所有的偶数位上都是偶数，要么所有的奇数位上都是奇数上。 
要求：如果数组长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1),下标0,2,4,6...算作偶数位,下标1,3,5,7...算作奇数位，
例如[1,2,3,4]调整为[2,1,4,3]即可


class Solution {
public:
	/**
	*  奇数位上都是奇数或者偶数位上都是偶数
	*  输入：数组arr，长度大于2
	*  len：arr的长度
	*  将arr调整成奇数位上都是奇数或者偶数位上都是偶数
	*/
	void oddInOddEvenInEven(vector<int>& vec, int len) {
		int first = 0;
		int last = vec.size() - 1;
		for (int first = 0; first < vec.size(); ++first) {
			if (first % 2 == 0 && vec[first] % 2 != 0) {
				int i = first + 1;
				for (; i < vec.size(); ++i) {
					if (vec[i] % 2 == 0) break;
				}
				if (i < vec.size()){
					int tmp = vec[first];
					vec[first] = vec[i];
					vec[i] = tmp;
				}
			}
			else if (first % 2 != 0 && vec[first] == 0) {
				int i = first + 1;
				for (; i < vec.size(); ++i) {
					if (vec[i] % 2 != 0) break;
				}
				if (i < vec.size()){
					int tmp = vec[first];
					vec[first] = vec[i];
					vec[i] = tmp;
				}
			}
		}
	}

}；